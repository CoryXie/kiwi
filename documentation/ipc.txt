Kiwi IPC
========

License
-------

This document is distributed under the terms of the [Creative Commons
Attribution-Noncommercial-Share Alike 3.0 Unported](http://creativecommons.org/
licenses/by-nc-sa/3.0/) license.

Introduction
------------

The purpose of this document is to explain how the IPC system used in Kiwi
works.

There are 3 main concepts within the IPC system:

 * _Port_

   A port represents a point of connection to a service.

 * _Connection_

   A connection is a bi-directional communication channel across a port.

 * _Message_

   A message is the data transferred through a connection.

Ports
-----

A port is an object which allows a service to be connected to. When a port is
created, it is assigned a global, unique integer ID, which can be used to refer
to it. Its creator is also given a handle to the port. Ports must be operated
on through a handle to the port, rather than operating on the port ID. There
are two reasons for this. Firstly, it allows ports to be cleaned up easily:
just delete them when no more handles are open to them. Secondly, it allows
them to be waited on using the object waiting interface.

Connections
-----------

A process opens a connection by calling `ipc_connection_open` with the ID of
the port it wishes to connect to. This call will block until either the
specified timeout passes, or the connection is accepted. When a connection is
established, the processes on each end of the connection are given a handle
referring to their end of the connection, which can be used to send and receive
messages. A connection is automatically terminated if the port that it is on is
deleted.

Messages
--------

A message consists of a type (a 32-bit integer that can be used by the
recipient to determine what the message contains) and a variable-length data
buffer.

Messages are sent asynchronously, and are queued to their destination in a FIFO
fashion. There is a limit on the number of messages that can be queued at any
one time - if an attempt to send a message is made and the destination's
message queue is full, then the send call will block until there is space in
the queue.

API
---

The following section describes the system call API for the IPC system. All
functions and types are defined in the header file `kernel/ipc.h`.

### Ports

    handle_t ipc_port_create(void);

The `ipc_port_create` function creates a new IPC port and returns a handle to
it. The port's ACL is initially set up to give full access to the calling
process.

When the port is no longer needed, the handle to it should be closed with
`handle_close`. The port will be deleted when there are no more handles that
refer to it. Any connections that are open on the port will be terminated if
this happens.

    handle_t ipc_port_open(port_id_t id);

The `ipc_port_open` function opens a handle to an IPC port.

    port_id_t ipc_port_id(handle_t handle);

The `ipc_port_id` function returns the global ID of the port referred to by
the given handle.

    handle_t ipc_port_listen(handle_t handle, useconds_t timeout);

The `ipc_port_listen` function listens for a connection on a port. The
function will block until either a connection is made to the port, or until
the timeout expires, in which case it will return an error. The timeout is
specified in microseconds. If the timeout is specified as -1, the function will
block indefinitely until a connection is made to the port. The function returns
a handle referring to caller's end of the connection.

### Connections

    handle_t ipc_connection_open(port_id_t id);

The `ipc_connection_open` function opens a connection to a port. Upon
success, this function returns a handle referring to the caller's end of the
connection. The function will block until the connection is accepted.

When the connection is no longer required, the handle should be closed with
`handle_close`. Doing so will discard all messages queued on the caller's end
of the connection, and attempts to send messages by the other end of the
connection after the connection has been closed will return an error.

### Messages

    int ipc_message_send(handle_t handle, uint32_t type, const void *buf,
                         size_t size);

The `ipc_message_send` function asynchronously sends a message through a
connection, and queues it at the other end. If the remote message queue is
full, then the caller will block until space is available.

    typedef struct ipc_message_vector {
    	uint32_t type;
    	void *buf;
    	size_t size;
    } ipc_message_vector_t;

    int ipc_message_sendv(handle_t handle, ipc_message_vector_t *vec,
                          size_t count);

The `ipc_message_sendv` function is capable of sending multiple messages on a
single call. The call should be provided with a pointer to an array of
`ipc_message_vector_t` structures, which describe the messages to send. The
messages are sent in the order that they are in the array. The operation is
atomic: the destination will not receive any of the messages until all have
been successfully queued, and if a failure occurs, it will receive none of the
messages.

    int ipc_message_peek(handle_t handle, useconds_t timeout,
                         uint32_t *typep, size_t *sizep);

The `ipc_message_peek` function waits until a message arrives on a connection,
and then returns the type and size of the message, leaving the message on the
queue. The function will block until either a message arrives, or until the
timeout expires, in which case it will return an error. The timeout is
specified in microseconds. If the timeout is specified as -1, the function will
block indefinitely until a message is received.

The purpose of this function is to allow a thread to wait for a message,
allocate a buffer large enough for the message data and then receive it.

    int ipc_message_receive(handle_t handle, useconds_t timeout,
                            uint32_t *typep, void *buf,
                            size_t size);

The `ipc_message_receive` function attempts to receive a message from a
connection. The function will block until either a message arrives on the
connection, or until the timeout expires, in which case it will return an
error. The timeout is specified in microseconds. If the timeout is specified
as -1, the function will block indefinitely until a message is received.

Note that if the message being received is larger than the provided buffer, the
extra data will be discarded. This behaviour can be exploited to discard
an unwanted message, by giving a 0 size.
