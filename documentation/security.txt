Security Model
==============

License
-------

This document is distributed under the terms of the [Creative Commons
Attribution-Noncommercial-Share Alike 3.0 Unported](http://creativecommons.org/
licenses/by-nc-sa/3.0/) license.

Introduction
------------

The purpose of this document is to describe the security model used by Kiwi to
control access to objects and what processes are allowed to do.

There are two methods of security used by the kernel:

 * **Object ACLs**

   The Kiwi kernel is object-oriented: most resources accessible by userspace
   are represented by kernel objects, which can be accessed through a handle.
   The object manager maintains an access control list (ACL) for each object,
   which controls what can access them.

 * **Capabilities**

   Capabilities are used to control use of kernel operations that do not
   operate on an object, for example shutdown/reboot, loading modules, etc.

The following sections will describe in depth how each of these mechanisms
work.

Security Context
----------------

The core part of the security model is the security context. Each process has
a security context which contains its user ID, a set of group IDs for each
group the process belongs to and a set of capabilities that the process has.

When creating a process, it can be given a new security context, or a copy of
the parent's. However, a new security context cannot have capabilities that the
parent does not have, and the user/group IDs cannot be changed unless the
parent has the capability (CAP_CHANGE_IDENTITY) to do so. A process can also
change its own security context, but the aforementioned restrictions apply.

Users, Groups and Sessions
--------------------------

The only knowledge of users and groups that the kernel has is user and group
IDs. User/group names, logging in, etc are handled in userspace.

When a user logs in, the first process in the session is created with a
security context containing the ID for their user, all of the group IDs for the
user, and a set of capabilities allowed for their account and groups.

Sessions are groups of processes that are represented by an ID allocated by the
kernel. They are used by userspace to group processes by the login session that
they are under in order to support multiple users being logged in at the same
time. Sessions are created by using the `PROCESS_CREATE_SESSION` flag with
`process_create`, and the capability to do so is kept only by the security
server (see below).

Object ACLs
-----------

Each object type has a set of rights that control what can be done with objects.
For example, the file object type has Read, Write and Execute rights. The ACL
defines which rights should be given to processes, and can contain the following
entry types:

 * **User** - Specifies rights for a user.
 * **Group** - Specifies rights for all users in a group.
 * **Others** - Specifies rights for processes that do not match any user or
   group entries.
 * **Session** - Specifies rights for all processes in a session.
 * **Capability** - Specifies rights for all processes with a certain
   capability.

The following determines how the set of rights a process is allowed for an
object is determined:

 * If a user entry matches the process' user ID, the rights it specifies will
   be added to the set of allowed rights.
 * Otherwise, if any group entries match any of the groups the process is in,
   the rights specified by each matching entry will be added to the set of
   allowed rights.
 * Otherwise, if an others entry exists, the rights it specifies will be added
   to the set of allowed rights.
 * If a session entry matches the process' session ID, the rights it specifies
   will be added to the set of allowed rights.
 * If capability entries exist for any of the process' capabilities, the rights
   specified by each matching entry will be added to the set of allowed rights.

When opening a handle to an object, a set of requested rights must be specified.
If any of the requested rights are not in the set of rights allowed to the
process, the open call is denied. Otherwise, the handle is created with the
requested rights. This means that the ACL is only checked at open time, and
operations on a handle only need to check if it has the necessary rights.

Security Server
---------------

The security server is a userspace service that manages user accounts, groups
and sessions. It exposes an RPC interface that allows clients to manage user
accounts, create and switch sessions, and to change their security context to
that of another user.

Internally, the server assigns permissions to sessions, to restrict creation
and switching of sessions. Only processes under session 0 are allowed to
create new sessions and switch to any session. Processes under other sessions
can only switch to session 0. This means that processes under user sessions
cannot switch to a different user's session without going through the login
prompt to authenticate as that user.

The facility to change to the security context of another user is used to
allow a program to be run as another user (like the UNIX `su` utility):
prompt for user and password to switch to, send these to security server,
security server sets context of caller to that of the user if successful, and
the new program is started. The use of this functionality can be restricted
to certain users/groups. To allow this to work, the security server has a
special capability (CAP_SECURITY_AUTHORITY) that allows it to modify the
security context of any process.

Notes
-----

Under this model it is impossible for support for the SUID/SGID bit to be
implemented in the POSIX compatibility layer. In my opinion, that's a good
thing.

TODO
----

 * Userspace privileges system for programs to define custom privileges for
   things like adding printers, installing software, etc. (like Mac OS X's
   Authorization Services and PolicyKit).
