#
# Copyright (C) 2009-2011 Alex Smith
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#

Import('envmgr', 'config')

dist = envmgr['dist']

#################
# Kernel build. #
#################

# Build the kernel and drivers.
SConscript(dirs = ['kernel', 'drivers'])

################
# KBoot build. #
################

# Create the build environment for the bootloader.
env = envmgr.Create('boot', {
	'LIBS': [],
	'CCFLAGS': [ '-nostdlib', '-nostdinc', '-ffreestanding', '-fno-stack-protector'],
	'ASFLAGS': ['-nostdinc'],
	'LINKFLAGS': ['-nostdlib'],
})

# Override any optimisation level specified, we want to optimise for size.
env['CCFLAGS'] = filter(lambda f: f[0:2] != '-O', env['CCFLAGS']) + ['-Os']

# Add the GCC include directory for some standard headers.
from subprocess import Popen, PIPE
incdir = Popen([env['CC'], '-print-file-name=include'], stdout = PIPE).communicate()[0].strip()
env['CCFLAGS'] += ['-isystem', incdir]
env['ASFLAGS'] += ['-isystem', incdir]

# Build the bootloader.
defaults = []
SConscript(dirs = ['boot'], exports = ['env', 'defaults'])
for t in defaults:
	if t[0].name != 'loader':
		Depends(File('boot/loader'), t)

# Put stuff into the distribution environment.
dist['LOADER'] = File('boot/loader')
if config['PLATFORM'] == 'pc':
	dist['CDBOOT'] = File('boot/platform/pc/stage1/cdboot')

####################
# Userspace build. #
####################

# Set up the userspace build environment.
env = envmgr.Create('uspace', {
	'CPPPATH': [Dir('include')],
	'LIBPATH': [Dir('libraries')],
	'ASFLAGS': ['-include', 'build/%s-%s/config.h' % (config['ARCH'], config['PLATFORM'])],
	'CCFLAGS': ['-include', 'build/%s-%s/config.h' % (config['ARCH'], config['PLATFORM'])],
	'CXXFLAGS': ['-std=c++0x'],
	'LIBOUTDIR': Dir('libraries'),
	'_LIBS': {}
})

# Process library dependencies, and set LIBS and CPPPATH in flags.
def process_library_deps(env, flags, libraries, build_libraries):
	if not flags.has_key('LIBS'):
		flags['LIBS'] = []
	if not flags.has_key('CPPPATH'):
		flags['CPPPATH'] = [] + env['CPPPATH']

	# Work out libraries to link against.
	def add_library(lib, link):
		if link and flags['LIBS'].count(lib) == 0:
			flags['LIBS'].append(lib)
		if env['_LIBS'].has_key(lib):
			info = env['_LIBS'][lib]
			process_library_deps(env, flags, [], info['build_libraries'])
			flags['CPPPATH'] += info['include_path']
	for lib in libraries:
		add_library(lib, True)
	for lib in build_libraries:
		add_library(lib, False)

# Custom method to build a Kiwi application.
def kiwi_application_method(env, target, sources, libraries = None, build_libraries = None, flags = None):
	if not libraries:
		libraries = []
	if not build_libraries:
		build_libraries = []
	if not flags:
		flags = {}

	# Set up the include path and get the libraries to link to.
	process_library_deps(env, flags, libraries, build_libraries)

	# Add the application to the distribution environment.
	dist['BINARIES'].append(File(target))

	# Build the application.
	return env.Program(target, sources, **flags)
env.AddMethod(kiwi_application_method, 'KiwiApplication')

# Custom method to build a Kiwi service.
def kiwi_service_method(env, target, sources, libraries = None, build_libraries = None, flags = None):
	if not libraries:
		libraries = []
	if not build_libraries:
		build_libraries = []
	if not flags:
		flags = {}

	# Set up the include path and get the libraries to link to.
	process_library_deps(env, flags, libraries, build_libraries)

	# Add the service to the distribution environment.
	dist['SERVICES'].append(File(target))

	# Build the service.
	return env.Program(target, sources, **flags)
env.AddMethod(kiwi_service_method, 'KiwiService')

# Custom method to build a Kiwi library.
def kiwi_library_method(env, target, sources, libraries = None, build_libraries = None,
                        include_path = None, flags = None):
	if not libraries:
		libraries = []
	if not build_libraries:
		build_libraries = []
	if not include_path:
		include_path = []
	elif type(include_path) != list:
		include_path = [include_path]
	if not flags:
		flags = {}

	# We want to use our own include directory.
	if include_path:
		if not flags.has_key('CPPPATH'):
			flags['CPPPATH'] = [] + env['CPPPATH']
		flags['CPPPATH'] += include_path

	# Set up the include path and get the libraries to link to.
	process_library_deps(env, flags, libraries, build_libraries)

	# Store our dependency/include path information.
	env['_LIBS'][target] = {
		'build_libraries': build_libraries,
		'include_path': include_path,
	}

	# Modify the target path so that libraries all get placed in the build
	# library directory.
	target = File('%s/lib%s.so' % (str(env['LIBOUTDIR']), target))

	# Add the library to the distribution environment.
	dist['LIBRARIES'].append(target)

	# Build the library.
	return env.SharedLibrary(target, sources, **flags)
env.AddMethod(kiwi_library_method, 'KiwiLibrary')

# Set up a shared library emitter to set dependencies on default libraries.
def shlib_emitter(target, source, env):
	if not ('-nostdlib' in env['LINKFLAGS'] or '-nostartfiles' in env['LINKFLAGS']):
		Depends(target[0], env['LIBOUTDIR'].glob('*crt*.o'))
	if not ('-nostdlib' in env['LINKFLAGS'] or '-nodefaultlibs' in env['LINKFLAGS']):
		Depends(target[0], env['LIBOUTDIR'].File('libc.so'))
	return target, source
env.Append(SHLIBEMITTER = [shlib_emitter])

# Set up a program emitter to set dependencies on default libraries.
def program_emitter(target, source, env):
	if not ('-nostdlib' in env['LINKFLAGS'] or '-nostartfiles' in env['LINKFLAGS']):
		Depends(target[0], env['LIBOUTDIR'].glob('*crt*.o'))
	if not ('-nostdlib' in env['LINKFLAGS'] or '-nodefaultlibs' in env['LINKFLAGS']):
		Depends(target[0], env['LIBOUTDIR'].File('libc.so'))
		if env['SMARTLINK'](source, target, env, None) == '$CXX':
			Depends(target[0], env['LIBOUTDIR'].File('libstdc++.so'))
	return target, source
env.Append(PROGEMITTER = [program_emitter])

# Add an action for ASM files in a shared library.
from SCons.Tool import createObjBuilders
static_obj, shared_obj = createObjBuilders(env)
shared_obj.add_action('.S', Action('$CC $_CCCOMCOM $ASFLAGS -DSHARED -c -o $TARGET $SOURCES', '$ASCOMSTR'))

# Build userspace.
SConscript(dirs = ['libraries', 'services', 'binaries'], exports = ['env'])
