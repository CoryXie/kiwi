# Copyright (C) 2009-2010 Alex Smith
#
# Kiwi is open source software, released under the terms of the Non-Profit
# Open Software License 3.0. You should have received a copy of the
# licensing information along with the source code distribution. If you
# have not received a copy of the license, please refer to the Kiwi
# project website.
#
# Please note that if you modify this file, the license requires you to
# ADD your name to the list of contributors. This boilerplate is not the
# license itself; please refer to the copy of the license you have received
# for complete terms.

Import('config', 'envmgr', 'version')

sources = map(File, [
	'console/console.c',
	'console/copyright.c',
	'console/fb.c',
	'console/font.c',
	'console/logo.c',

	'cpu/cpu.c',
	'cpu/fpu.c',
	'cpu/ipi.c',
	'cpu/irq.c',

	'io/context.c',
	'io/device.c',
	'io/entry_cache.c',
	'io/file_map.c',
	'io/fs.c',
	'io/ramfs.c',

	'ipc/ipc.c',
	'ipc/pipe.c',

	'lib/avl_tree.c',
	'lib/bitmap.c',
	'lib/hash.c',
	'lib/notifier.c',
	'lib/printf.c',
	'lib/qsort.c',
	'lib/radix_tree.c',
	'lib/string.c',

	'mm/area.c',
	'mm/kheap.c',
	'mm/malloc.c',
	'mm/page.c',
	'mm/safe.c',
	'mm/slab.c',
	'mm/vm.c',
	'mm/vm_cache.c',

	'proc/process.c',
	'proc/sched.c',
	'proc/session.c',
	'proc/thread.c',

	'sync/condvar.c',
	'sync/mutex.c',
	'sync/rwlock.c',
	'sync/semaphore.c',
	'sync/spinlock.c',
	'sync/waitq.c',

	'elf.c',
	'fatal.c',
	'init.c',
	'kdbg.c',
	'lrm.c',
	'module.c',
	'object.c',
	'symbol.c',
	'syscall_table.c',
	'time.c',
	'version.c',
	'vmem.c',
])

############################
# Build environment set-up #
############################

# Create the kernel environment.
env = envmgr.Create('kernel', {
	'LIBS': [],
	'CPPPATH': [
		Dir('include'),
		Dir('arch/%s/include' % (config['SRCARCH'])),
		Dir('platform/%s/include' % (config['PLATFORM'])),
	],
	'CCFLAGS': [
		'-nostdlib', '-nostdinc', '-ffreestanding',
		'-fno-stack-protector', '-include',
		'build/%s-%s/config.h' % (config['ARCH'], config['PLATFORM']),
	],
	'CXXFLAGS': [
		'-fno-exceptions', '-fno-rtti',
	],
	'ASFLAGS': [
		'-nostdinc', '-include',
		'build/%s-%s/config.h' % (config['ARCH'], config['PLATFORM']),
	],
	'LINKFLAGS': [
		'-nostdlib',
	],
	'CPPDEFINES': {
		'KERNEL': None,
	},
})

# Set up stuff for using clang.
if config['USE_CLANG']:
	if env['ENV'].has_key('CCC_CC'):
		env['CCC_CC'] = 'clang'
	else:
		env['CC'] = 'clang'

# Generate the version information file.
def gen_version_c(target, source, env):
	f = open(str(target[0]), 'w')
	f.write('int kiwi_ver_release = %d;\n' % (version['KIWI_VER_RELEASE']))
	f.write('int kiwi_ver_update = %d;\n' % (version['KIWI_VER_UPDATE']))
	f.write('int kiwi_ver_revision = %d;\n' % (version['KIWI_VER_REVISION']))
	f.write('const char *kiwi_ver_string = "%s";\n' % (version['KIWI_VER_STRING']))
	f.close()
AlwaysBuild(env.Command('version.c', [], env.Action(gen_version_c, None)))

# Generate the boot splash image source files.
env.Command('console/logo.c', ['console/logo.ppm'],
            Action('$BIN2HEX $SOURCE logo_ppm > $TARGET', '$GENCOMSTR'))
env.Command('console/copyright.c', ['console/copyright.ppm'],
            Action('$BIN2HEX $SOURCE copyright_ppm > $TARGET', '$GENCOMSTR'))

# Generate the system call table.
env['SYSCALLS'] = File('syscalls.def')
env.SyscallTable('syscall_table.c', env['SYSCALLS'], TABLE='syscall_table')

# Get the list of source files from the architecture/platform.
arch_sources = SConscript(dirs=['arch/' + config['SRCARCH']], exports=['env'])
platform_sources = SConscript(dirs=['platform/' + config['PLATFORM']], exports=['env'])
sources = arch_sources + platform_sources + sources

# Create a fake symbol table used for the first linking stage.
def fake_symtab_func(target, source, env):
	f = open(str(target[0]), 'w')
	f.write('/* This file is auto-generated, changes will be overwritten. */\n')
	f.write('#include <symbol.h>\n')
	f.write('static symbol_t kernel_symtab_array[] = { { { NULL, NULL }, 0x0, 0x0, "dummy", 0, false } };\n')
	f.write('symbol_table_t kernel_symtab = { .symbols = kernel_symtab_array, .count = 1 };\n')
	f.close()
	return None

# Link the first kernel image using a fake symbol table.
env.Command('fake-symtab.c', [], Action(fake_symtab_func, '$GENCOMSTR'))
env.Program('kernel-pass1', map(env.Object, sources) + ['fake-symtab.c'],
            LINKFLAGS=env['LINKFLAGS'] + ['-Wl,-T,$LDSCRIPT'])
Depends('kernel-pass1', env['LDSCRIPT'])

# Generate the first real symbol table and relink the kernel with it.
env.Command('symtab-pass1.c', ['kernel-pass1'],
            Action('$NM -S $SOURCE | sort | $GENSYMTAB kernel_symtab > $TARGET', '$GENCOMSTR'))
env.Program('kernel-pass2', map(env.Object, sources) + ['symtab-pass1.c'],
            LINKFLAGS=env['LINKFLAGS'] + ['-Wl,-T,$LDSCRIPT'])
Depends('kernel-pass2', env['LDSCRIPT'])

# Generate the final symbol table with correct symbol addresses.
env.Command('symtab-pass2.c', ['kernel-pass2'],
            Action('$NM -S $SOURCE | sort | $GENSYMTAB kernel_symtab > $TARGET', '$GENCOMSTR'))
env.Program('kernel-unstripped', map(env.Object, sources) + ['symtab-pass2.c'],
            LINKFLAGS=env['LINKFLAGS'] + ['-Wl,-T,$LDSCRIPT'])
Depends('kernel-unstripped', env['LDSCRIPT'])

# Generate various information files and the stripped kernel image.
env.Command('kernel.lst', 'kernel-unstripped', Action('$OBJDUMP -d $SOURCE > $TARGET', '$GENCOMSTR'))
env.Command('kernel.rde', 'kernel-unstripped', Action('$READELF -a $SOURCE > $TARGET', '$GENCOMSTR'))
env.Command('kernel.sym', 'kernel-unstripped', Action('$NM -C $SOURCE | sort > $TARGET', '$GENCOMSTR'))
env.Command('kernel', 'kernel-unstripped', Action('$STRIP --strip-debug $SOURCE -o $TARGET', '$GENCOMSTR'))
Depends('kernel', ['kernel.lst', 'kernel.rde', 'kernel.sym'])

# Let the distribution environment know where the kernel is.
envmgr['dist']['KERNEL'] = File('kernel')

# Build kernel modules.
SConscript(dirs=['modules'])
