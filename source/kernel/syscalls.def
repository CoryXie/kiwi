# Copyright (C) 2010 Alex Smith
#
# Kiwi is open source software, released under the terms of the Non-Profit
# Open Software License 3.0. You should have received a copy of the
# licensing information along with the source code distribution. If you
# have not received a copy of the license, please refer to the Kiwi
# project website.
#
# Please note that if you modify this file, the license requires you to
# ADD your name to the list of contributors. This boilerplate is not the
# license itself; please refer to the copy of the license you have received
# for complete terms.

type status_t int32_t;
type handle_t int32_t;
type process_id_t int32_t;
type thread_id_t int32_t;
type port_id_t int32_t;
type semaphore_id_t int32_t;
type area_id_t int32_t;
type mount_id_t uint16_t;
type node_id_t uint64_t;
type useconds_t int64_t;
type offset_t uint64_t;
type rel_offset_t int64_t;
type object_rights_t uint32_t;
type user_id_t int16_t;
type group_id_t int16_t;

syscall kern_fatal(ptr_t);
syscall kern_shutdown(int);
syscall kern_system_time(ptr_t);
syscall kern_unix_time(ptr_t);
syscall kern_module_load(ptr_t, ptr_t);
syscall kern_module_info(ptr_t, ptr_t);
syscall kern_object_type(handle_t);
syscall kern_object_security(handle_t, ptr_t, ptr_t, ptr_t) wrapped;
syscall kern_object_set_security(handle_t, ptr_t);
syscall kern_object_wait(ptr_t, size_t, useconds_t);
syscall kern_handle_control(handle_t, int, int, ptr_t);
syscall kern_handle_duplicate(handle_t, handle_t, bool, ptr_t);
syscall kern_handle_close(handle_t);
syscall kern_file_open(ptr_t, object_rights_t, int, int, ptr_t, ptr_t);
syscall kern_file_read(handle_t, ptr_t, size_t, ptr_t);
syscall kern_file_pread(handle_t, ptr_t, size_t, offset_t, ptr_t);
syscall kern_file_write(handle_t, ptr_t, size_t, ptr_t);
syscall kern_file_pwrite(handle_t, ptr_t, size_t, offset_t, ptr_t);
syscall kern_file_resize(handle_t, offset_t);
syscall kern_file_seek(handle_t, int, rel_offset_t, ptr_t);
syscall kern_file_info(handle_t, ptr_t);
syscall kern_file_sync(handle_t);
syscall kern_dir_create(ptr_t, ptr_t);
syscall kern_dir_read(handle_t, ptr_t, size_t);
syscall kern_symlink_create(ptr_t, ptr_t);
syscall kern_symlink_read(ptr_t, ptr_t, size_t);
syscall kern_fs_mount(ptr_t, ptr_t, ptr_t, ptr_t);
syscall kern_fs_mount_info(ptr_t, ptr_t);
syscall kern_fs_unmount(ptr_t);
syscall kern_fs_getcwd(ptr_t, size_t);
syscall kern_fs_setcwd(ptr_t);
syscall kern_fs_setroot(ptr_t);
syscall kern_fs_info(ptr_t, bool, ptr_t);
syscall kern_fs_security(ptr_t, bool, ptr_t, ptr_t, ptr_t) wrapped;
syscall kern_fs_set_security(ptr_t, bool, ptr_t);
syscall kern_fs_link(ptr_t, ptr_t);
syscall kern_fs_unlink(ptr_t);
syscall kern_fs_rename(ptr_t, ptr_t);
syscall kern_fs_sync();
syscall kern_device_open(ptr_t, object_rights_t, ptr_t);
syscall kern_device_read(handle_t, ptr_t, size_t, offset_t, ptr_t);
syscall kern_device_write(handle_t, ptr_t, size_t, offset_t, ptr_t);
syscall kern_device_request(handle_t, int, ptr_t, size_t, ptr_t, size_t, ptr_t);
syscall kern_vm_map(ptr_t, size_t, int, handle_t, offset_t, ptr_t);
syscall kern_vm_unmap(ptr_t, size_t);
syscall kern_process_create(ptr_t, ptr_t, ptr_t, int, ptr_t, ptr_t, int, ptr_t, object_rights_t, ptr_t);
syscall kern_process_replace(ptr_t, ptr_t, ptr_t, ptr_t, ptr_t, int);
syscall kern_process_clone(ptr_t, ptr_t, ptr_t, ptr_t, object_rights_t, ptr_t);
syscall kern_process_open(process_id_t, object_rights_t, ptr_t);
syscall kern_process_id(handle_t);
syscall kern_process_session(handle_t);
syscall kern_process_control(handle_t, int, ptr_t, ptr_t);
syscall kern_process_status(handle_t, ptr_t, ptr_t);
syscall kern_process_exit(int);
syscall kern_thread_create(ptr_t, ptr_t, size_t, ptr_t, ptr_t, ptr_t, object_rights_t, ptr_t) wrapped;
syscall kern_thread_open(thread_id_t, object_rights_t, ptr_t);
syscall kern_thread_id(handle_t);
syscall kern_thread_control(handle_t, int, ptr_t, ptr_t);
syscall kern_thread_status(handle_t, ptr_t);
syscall kern_thread_exit(int) wrapped;
syscall kern_thread_usleep(useconds_t);
syscall kern_port_create(ptr_t, object_rights_t, ptr_t);
syscall kern_port_open(port_id_t, object_rights_t, ptr_t);
syscall kern_port_id(handle_t);
syscall kern_port_listen(handle_t, useconds_t, ptr_t, ptr_t);
syscall kern_port_loopback(handle_t, ptr_t);
syscall kern_connection_open(port_id_t, ptr_t);
syscall kern_connection_send(handle_t, uint32_t, ptr_t, size_t);
syscall kern_connection_peek(handle_t, useconds_t, ptr_t, ptr_t);
syscall kern_connection_receive(handle_t, useconds_t, ptr_t, ptr_t, size_t);
syscall kern_semaphore_create(ptr_t, size_t, ptr_t, object_rights_t, ptr_t);
syscall kern_semaphore_open(semaphore_id_t, object_rights_t, ptr_t);
syscall kern_semaphore_id(handle_t);
syscall kern_semaphore_down(handle_t, useconds_t);
syscall kern_semaphore_up(handle_t, size_t);
syscall kern_area_create(size_t, handle_t, offset_t, ptr_t, object_rights_t, ptr_t);
syscall kern_area_open(area_id_t, object_rights_t, ptr_t);
syscall kern_area_id(handle_t);
syscall kern_area_size(handle_t);
syscall kern_area_resize(handle_t, size_t);
syscall kern_futex_wait(ptr_t, int32_t, useconds_t);
syscall kern_futex_wake(ptr_t, size_t, ptr_t);
syscall kern_timer_create(int, ptr_t);
syscall kern_timer_start(handle_t, useconds_t, int);
syscall kern_timer_stop(handle_t, ptr_t);
syscall kern_signal_send(handle_t, int);
syscall kern_signal_action(int, ptr_t, ptr_t) wrapped;
syscall kern_signal_mask(int, ptr_t, ptr_t);
syscall kern_signal_stack(ptr_t, ptr_t);
syscall kern_signal_return() hidden;
