# Copyright (C) 2010 Alex Smith
#
# Kiwi is open source software, released under the terms of the Non-Profit
# Open Software License 3.0. You should have received a copy of the
# licensing information along with the source code distribution. If you
# have not received a copy of the license, please refer to the Kiwi
# project website.
#
# Please note that if you modify this file, the license requires you to
# ADD your name to the list of contributors. This boilerplate is not the
# license itself; please refer to the copy of the license you have received
# for complete terms.

type status_t int32_t;
type handle_t int32_t;
type process_id_t int32_t;
type thread_id_t int32_t;
type port_id_t int32_t;
type semaphore_id_t int32_t;
type area_id_t int32_t;
type mount_id_t uint16_t;
type node_id_t uint64_t;
type useconds_t int64_t;
type offset_t uint64_t;
type rel_offset_t int64_t;
type object_rights_t uint32_t;
type user_id_t int16_t;
type group_id_t int16_t;

syscall system_fatal(ptr_t);
syscall system_shutdown(int);
syscall module_load(ptr_t, ptr_t);
syscall module_info(ptr_t, ptr_t);
syscall object_type(handle_t);
syscall object_security(handle_t, ptr_t, ptr_t, ptr_t) wrapped;
syscall object_set_security(handle_t, ptr_t);
syscall object_wait(ptr_t, size_t, useconds_t);
syscall handle_flags(handle_t, ptr_t);
syscall handle_set_flags(handle_t, int);
syscall handle_duplicate(handle_t, handle_t, bool, ptr_t);
syscall handle_close(handle_t);
syscall fs_file_open(ptr_t, object_rights_t, int, int, ptr_t, ptr_t);
syscall fs_file_read(handle_t, ptr_t, size_t, ptr_t);
syscall fs_file_pread(handle_t, ptr_t, size_t, offset_t, ptr_t);
syscall fs_file_write(handle_t, ptr_t, size_t, ptr_t);
syscall fs_file_pwrite(handle_t, ptr_t, size_t, offset_t, ptr_t);
syscall fs_file_resize(handle_t, offset_t);
syscall fs_dir_create(ptr_t, ptr_t);
syscall fs_dir_open(ptr_t, object_rights_t, int, ptr_t);
syscall fs_dir_read(handle_t, ptr_t, size_t);
syscall fs_handle_seek(handle_t, int, rel_offset_t, ptr_t);
syscall fs_handle_flags(handle_t, ptr_t);
syscall fs_handle_set_flags(handle_t, int);
syscall fs_handle_info(handle_t, ptr_t);
syscall fs_handle_sync(handle_t);
syscall fs_symlink_create(ptr_t, ptr_t);
syscall fs_symlink_read(ptr_t, ptr_t, size_t);
syscall fs_mount(ptr_t, ptr_t, ptr_t, ptr_t);
syscall fs_mount_info(ptr_t, ptr_t);
syscall fs_unmount(ptr_t);
syscall fs_sync();
syscall fs_getcwd(ptr_t, size_t);
syscall fs_setcwd(ptr_t);
syscall fs_setroot(ptr_t);
syscall fs_info(ptr_t, bool, ptr_t);
syscall fs_security(ptr_t, bool, ptr_t, ptr_t, ptr_t) wrapped;
syscall fs_set_security(ptr_t, bool, ptr_t);
syscall fs_link(ptr_t, ptr_t);
syscall fs_unlink(ptr_t);
syscall fs_rename(ptr_t, ptr_t);
syscall device_open(ptr_t, object_rights_t, ptr_t);
syscall device_read(handle_t, ptr_t, size_t, offset_t, ptr_t);
syscall device_write(handle_t, ptr_t, size_t, offset_t, ptr_t);
syscall device_request(handle_t, int, ptr_t, size_t, ptr_t, size_t, ptr_t);
syscall vm_map(ptr_t, size_t, int, handle_t, offset_t, ptr_t);
syscall vm_unmap(ptr_t, size_t);
syscall process_create(ptr_t, ptr_t, ptr_t, int, ptr_t, ptr_t, int, ptr_t, object_rights_t, ptr_t);
syscall process_replace(ptr_t, ptr_t, ptr_t, ptr_t, ptr_t, int);
syscall process_clone(ptr_t, ptr_t, ptr_t, ptr_t, object_rights_t, ptr_t);
syscall process_open(process_id_t, object_rights_t, ptr_t);
syscall process_id(handle_t);
syscall process_session(handle_t);
syscall process_security_context(handle_t, ptr_t);
syscall process_set_security_context(handle_t, ptr_t);
syscall process_status(handle_t, ptr_t);
syscall process_exit(int);
syscall process_loaded() hidden;
syscall thread_create(ptr_t, ptr_t, size_t, ptr_t, ptr_t, ptr_t, object_rights_t, ptr_t) wrapped;
syscall thread_open(thread_id_t, object_rights_t, ptr_t);
syscall thread_id(handle_t);
syscall thread_status(handle_t, ptr_t);
syscall thread_exit(int) wrapped;
syscall thread_usleep(useconds_t);
syscall thread_set_tls_addr(ptr_t) hidden;
syscall ipc_port_create(ptr_t, object_rights_t, ptr_t);
syscall ipc_port_open(port_id_t, object_rights_t, ptr_t);
syscall ipc_port_id(handle_t);
syscall ipc_port_listen(handle_t, useconds_t, ptr_t, ptr_t);
syscall ipc_connection_open(port_id_t, ptr_t);
syscall ipc_message_send(handle_t, uint32_t, ptr_t, size_t);
syscall ipc_message_sendv(handle_t, ptr_t, size_t);
syscall ipc_message_peek(handle_t, useconds_t, ptr_t, ptr_t);
syscall ipc_message_receive(handle_t, useconds_t, ptr_t, ptr_t, size_t);
syscall semaphore_create(ptr_t, size_t, ptr_t, object_rights_t, ptr_t);
syscall semaphore_open(semaphore_id_t, object_rights_t, ptr_t);
syscall semaphore_id(handle_t);
syscall semaphore_down(handle_t, useconds_t);
syscall semaphore_up(handle_t, size_t);
syscall area_create(size_t, handle_t, offset_t, ptr_t, object_rights_t, ptr_t);
syscall area_open(area_id_t, object_rights_t, ptr_t);
syscall area_id(handle_t);
syscall area_size(handle_t);
syscall area_resize(handle_t, size_t);
syscall time_since_boot(ptr_t);
syscall time_since_epoch(ptr_t);
syscall futex_wait(ptr_t, int32_t, useconds_t);
syscall futex_wake(ptr_t, size_t, ptr_t);
syscall timer_create(ptr_t);
syscall timer_start(handle_t, useconds_t, int);
syscall timer_stop(handle_t);
