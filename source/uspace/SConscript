# Kiwi build system
# Copyright (C) 2009 Alex Smith
#
# Kiwi is open source software, released under the terms of the Non-Profit
# Open Software License 3.0. You should have received a copy of the
# licensing information along with the source code distribution. If you
# have not received a copy of the license, please refer to the Kiwi
# project website.
#
# Please note that if you modify this file, the license requires you to
# ADD your name to the list of contributors. This boilerplate is not the
# license itself; please refer to the copy of the license you have received
# for complete terms.

Import('envmgr', 'config')

dist = envmgr['dist']

# Set up the userspace build environment.
env = envmgr.Create('uspace')
env['CPPPATH'] = [Dir('include'), Dir('include/c++')]
env['LIBPATH'] = [Dir('libraries')]
env['ASFLAGS'] += ['-include', 'build/%s-%s/config.h' % (config['ARCH'], config['PLATFORM'])]
env['CCFLAGS'] += ['-include', 'build/%s-%s/config.h' % (config['ARCH'], config['PLATFORM'])]

# Temporary.
env['CXXFLAGS'] += ['-fno-rtti', '-fno-exceptions']

# Set the directory that we want all libraries to be placed in.
env['LIBOUTDIR'] = Dir('libraries')

# Set up library emitters to modify the target path to get libraries placed
# in the correct location, add the library to the libraries array, and set
# dependencies for default libraries.
def lib_emitter(target, source, env):
	target[0] = File('%s/%s' % (str(env['LIBOUTDIR']), str(target[0])))
	dist['LIBRARIES'].append(target[0])
	return target, source
def shlib_emitter(target, source, env):
	lib_emitter(target, source, env)
	Depends(target[0], env['LIBOUTDIR'].glob('*crt*.o'))
	if target[0].name != 'libsystem.so':
		Depends(target[0], env['LIBOUTDIR'].File('libsystem.so'))
	return target, source
env.Append(LIBEMITTER=[lib_emitter])
env.Append(SHLIBEMITTER=[shlib_emitter])

# Set up a program emitter to add binaries to the binaries array and set
# up library dependencies for compiler default libraries (SCons doesn't pick
# these up).
def program_emitter(target, source, env):
	# Hack.
	if target[0].get_dir().get_dir().name == 'services':
		dist['SERVICES'].append(target[0])
	else:
		dist['BINARIES'].append(target[0])
	if target[0].name != 'rtld-%s' % (config['ARCH']):
		Depends(target[0], env['LIBOUTDIR'].File('libsystem.so'))
		if env['SMARTLINK'](source, target, env, None) == '$CXX':
			Depends(target[0], env['LIBOUTDIR'].File('libstdc++.so'))
	return target, source
env.Append(PROGEMITTER=[program_emitter])

# Add a builder to generate system call functions.
env['SYSINC'] = File('libraries/libsystem/arch/%s/syscalls.inc' % (config['ARCH']))
def sysgen_emitter(target, source, env):
	source.insert(0, env['SYSINC'])
	return target, source
env['BUILDERS']['Sysgen'] = Builder(action=Action('$SYSGEN $TARGET $SOURCES', '$GENCOMSTR'), emitter=sysgen_emitter)

# Visit subdirectories.
SConscript(dirs=['libraries', 'binaries', 'services'], exports=['env'])
