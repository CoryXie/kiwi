# Copyright (C) 2010 Alex Smith
#
# Kiwi is open source software, released under the terms of the Non-Profit
# Open Software License 3.0. You should have received a copy of the
# licensing information along with the source code distribution. If you
# have not received a copy of the license, please refer to the Kiwi
# project website.
#
# Please note that if you modify this file, the license requires you to
# ADD your name to the list of contributors. This boilerplate is not the
# license itself; please refer to the copy of the license you have received
# for complete terms.

service 0;

int module_load(ptr_t, ptr_t);
int object_type(handle_t);
int object_wait(handle_t, int, useconds_t);
int object_wait_multiple(ptr_t, ptr_t, size_t, useconds_t);
int handle_get_flags(handle_t);
int handle_set_flags(handle_t, int);
int handle_close(handle_t);
int fs_file_create(ptr_t);
handle_t fs_file_open(ptr_t, int);
int fs_file_read(handle_t, ptr_t, size_t, ptr_t);
int fs_file_pread(handle_t, ptr_t, size_t, offset_t, ptr_t);
int fs_file_write(handle_t, ptr_t, size_t, ptr_t);
int fs_file_pwrite(handle_t, ptr_t, size_t, offset_t, ptr_t);
int fs_file_resize(handle_t, offset_t);
int fs_dir_create(ptr_t);
handle_t fs_dir_open(ptr_t, int);
int fs_dir_read(handle_t, ptr_t, size_t, offset_t);
int fs_handle_seek(handle_t, int, rel_offset_t, ptr_t);
int fs_handle_info(handle_t, ptr_t);
int fs_handle_sync(handle_t);
int fs_symlink_create(ptr_t, ptr_t);
int fs_symlink_read(ptr_t, ptr_t, size_t);
int fs_mount(ptr_t, ptr_t, ptr_t, int);
int fs_unmount(ptr_t);
int fs_sync();
int fs_getcwd(ptr_t, size_t);
int fs_setcwd(ptr_t);
int fs_setroot(ptr_t);
int fs_info(ptr_t, bool, ptr_t);
int fs_link(ptr_t, ptr_t);
int fs_unlink(ptr_t);
int fs_rename(ptr_t, ptr_t);
int _vm_map(ptr_t);
int vm_unmap(ptr_t, size_t);
handle_t process_create(ptr_t, ptr_t, ptr_t, int, ptr_t, int);
int process_replace(ptr_t, ptr_t, ptr_t, ptr_t, int);
int process_clone(ptr_t);
handle_t process_open(process_id_t);
process_id_t process_id(handle_t);
int process_status(handle_t, ptr_t);
void process_exit(int);
handle_t device_open(ptr_t);
int device_read(handle_t, ptr_t, size_t, offset_t, ptr_t);
int device_write(handle_t, ptr_t, size_t, offset_t, ptr_t);
int _device_request(ptr_t);
handle_t thread_create(ptr_t, ptr_t, size_t, ptr_t, ptr_t);
handle_t thread_open(thread_id_t);
thread_id_t thread_id(handle_t);
void thread_exit(int);
int thread_usleep(useconds_t);
handle_t semaphore_create(ptr_t, size_t);
handle_t semaphore_open(ptr_t, size_t);
semaphore_id_t semaphore_id(handle_t);
int semaphore_down(handle_t, useconds_t);
int semaphore_up(handle_t, size_t);
handle_t ipc_port_create();
handle_t ipc_port_open(port_id_t);
port_id_t ipc_port_id(handle_t);
handle_t ipc_port_listen(handle_t, useconds_t);
handle_t ipc_connection_open(port_id_t);
int ipc_message_send(handle_t, uint32_t, ptr_t, size_t);
int ipc_message_sendv(handle_t, ptr_t, size_t);
int ipc_message_peek(handle_t, useconds_t, ptr_t, ptr_t);
int ipc_message_receive(handle_t, useconds_t, ptr_t, ptr_t, size_t);
handle_t shm_create(size_t);
handle_t shm_open(shm_id_t);
shm_id_t shm_id(handle_t);
int shm_resize(handle_t, size_t);
