/*
 * Copyright (C) 2010 Alex Smith
 *
 * Kiwi is open source software, released under the terms of the Non-Profit
 * Open Software License 3.0. You should have received a copy of the
 * licensing information along with the source code distribution. If you
 * have not received a copy of the license, please refer to the Kiwi
 * project website.
 *
 * Please note that if you modify this file, the license requires you to
 * ADD your name to the list of contributors. This boilerplate is not the
 * license itself; please refer to the copy of the license you have received
 * for complete terms.
 */

/**
 * @file
 * @brief		IA32 system call code generator.
 */

#include <boost/foreach.hpp>

#include "IA32Target.h"

using namespace std;

/** Add this target's types to the type map.
 * @param map		Map to add to. */
void IA32Target::addTypes(TypeMap &map) {
	map["int"] = new Type(32, 1, true);
	map["char"] = new Type(8, 1, true);
	map["bool"] = new Type(1, 1, false);
	map["ptr_t"] = new Type(32, 1, false);
	map["size_t"] = new Type(32, 1, false);
	map["int8_t"] = new Type(8, 1, true);
	map["int16_t"] = new Type(16, 1, true);
	map["int32_t"] = new Type(32, 1, true);
	map["int64_t"] = new Type(64, 2, true);
	map["uint8_t"] = new Type(8, 1, false);
	map["uint16_t"] = new Type(16, 1, false);
	map["uint32_t"] = new Type(32, 1, false);
	map["uint64_t"] = new Type(64, 2, false);
}

/** Get the maximum number of parameters allowed to a call.
 * @return		Maximum number of parameters. */
size_t IA32Target::maxParameters() {
	return 6;
}

/** Generate a push instruction. */
#define GENERATE_PUSH(name)	pushed.push_front((name)); stream << "	push	" name << endl;

/** Generate the system call code.
 * @param stream	Stream to write output to.
 * @param calls		List of system calls.
 * @param use_errno	Whether to generate code to set errno. */
void IA32Target::generate(std::ostream &stream, const SyscallList &calls, bool use_errno) {
	stream << "/* This file is automatically generated. Do not edit! */" << endl;
	stream << "#ifdef SHARED" << endl;
	stream << "__sysgen_get_pc:" << endl;
	stream << "	movl (%esp), %ebx" << endl;
	stream << "	ret" << endl;
	stream << "#endif" << endl;

	BOOST_FOREACH(const Syscall *call, calls) {
		/* Write the common code for all calls. */
		stream << endl;
		stream << ".global " << call->getName() << endl;
		stream << ".type " << call->getName() << ", @function" << endl;
		stream << call->getName() << ':' << endl;
		stream << "	movl	$" << call->getID() << ", %eax" << endl;

		/* Now the difficult part - handling different numbers of
		 * arguments. We use callee-save registers for some things so
		 * must save them. Create a list of pushed registers so we can
		 * write out pops for them after without having to do a case
		 * for each number of arguments. The list is in the order to be
		 * popped in. */
		list<string> pushed;
		switch(call->getParameterCount()) {
		case 1:
			stream << "	movl	4(%esp), %edx" << endl;
			break;
		case 2:
			stream << "	movl	4(%esp), %edx" << endl;
			stream << "	movl	8(%esp), %ecx" << endl;
			break;
		case 3:
			GENERATE_PUSH("%edi");
			stream << "	movl	8(%esp), %edx" << endl;
			stream << "	movl	12(%esp), %ecx" << endl;
			stream << "	movl	16(%esp), %edi" << endl;
			break;
		case 4:
			GENERATE_PUSH("%edi");
			GENERATE_PUSH("%esi");
			stream << "	movl	12(%esp), %edx" << endl;
			stream << "	movl	16(%esp), %ecx" << endl;
			stream << "	movl	20(%esp), %edi" << endl;
			stream << "	movl	24(%esp), %esi" << endl;
			break;
		case 5:
			GENERATE_PUSH("%edi");
			GENERATE_PUSH("%esi");
			GENERATE_PUSH("%ebx");
			stream << "	movl	16(%esp), %edx" << endl;
			stream << "	movl	20(%esp), %ecx" << endl;
			stream << "	movl	24(%esp), %edi" << endl;
			stream << "	movl	28(%esp), %esi" << endl;
			stream << "	movl	32(%esp), %ebx" << endl;
			break;
		case 6:
			GENERATE_PUSH("%edi");
			GENERATE_PUSH("%esi");
			GENERATE_PUSH("%ebx");
			GENERATE_PUSH("%ebp");
			stream << "	movl	20(%esp), %edx" << endl;
			stream << "	movl	24(%esp), %ecx" << endl;
			stream << "	movl	28(%esp), %edi" << endl;
			stream << "	movl	32(%esp), %esi" << endl;
			stream << "	movl	36(%esp), %ebx" << endl;
			stream << "	movl	40(%esp), %ebp" << endl;
			break;
		}

		/* Perform the call and pop pushed registers. */
		stream << "	int	$0x80" << endl;
		BOOST_FOREACH(const std::string &str, pushed) {
			stream << "	pop	" << str << endl;
		}

		/* If the return type is signed and the function returns a
		 * negative value, set the error number. */
		Type *type = call->getReturnType();
		if(type && type->is_signed && use_errno) {
			if(type->width == 64) {
				stream << "	test	%edx, %edx" << endl;
			} else {
				stream << "	test	%eax, %eax" << endl;
			}
			stream << "	js	1f" << endl;
			stream << "	ret" << endl;
			stream << "1:	neg	%eax" << endl;
			stream << "	push	%eax" << endl;
			stream << "#ifdef SHARED" << endl;
			stream << "	push	%ebx" << endl;
			stream << "	call	__sysgen_get_pc" << endl;
			stream << "	addl	$_GLOBAL_OFFSET_TABLE_, %ebx" << endl;
			stream << "	call	__libsystem_errno_location@PLT" << endl;
			stream << "	pop 	%ebx" << endl;
			stream << "#else" << endl;
			stream << "	call	__libsystem_errno_location" << endl;
			stream << "#endif" << endl;
			stream << "	pop	%edx" << endl;
			stream << "	movl	%edx, (%eax)" << endl;
			stream << "	movl	$-1, %eax" << endl;
			stream << "	movl	$-1, %edx" << endl;
			stream << "	ret" << endl;
		} else {
			stream << "	ret" << endl;
		}

		stream << ".size " << call->getName() << ", .-" << call->getName() << endl;
	}
}
